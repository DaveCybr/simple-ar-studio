<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AR Viewer - Multi Target</title>
    <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.1.4/dist/mindar-image.prod.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.1.4/dist/mindar-image-aframe.prod.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        color: white;
        font-family: system-ui, -apple-system, sans-serif;
      }
      .loading.hidden {
        display: none;
      }
      .progress-container {
        width: 80%;
        max-width: 300px;
        margin: 20px 0;
      }
      .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        border-radius: 3px;
        transition: width 0.3s ease;
        width: 0%;
      }
      .progress-text {
        text-align: center;
        margin-top: 12px;
        font-size: 14px;
        opacity: 0.9;
      }
      .progress-detail {
        text-align: center;
        font-size: 12px;
        opacity: 0.6;
        margin-top: 6px;
      }
      .hint {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 14px;
        z-index: 100;
        text-align: center;
        backdrop-filter: blur(10px);
        max-width: 90%;
      }
      .marker-count {
        position: fixed;
        top: 80px;
        right: 16px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 12px;
        z-index: 100;
        backdrop-filter: blur(10px);
      }
      .settings-btn {
        position: fixed;
        top: 80px;
        left: 16px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 10px 16px;
        border-radius: 20px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 12px;
        z-index: 100;
        backdrop-filter: blur(10px);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .settings-btn:hover {
        background: rgba(0, 0, 0, 0.85);
      }
      .settings-panel {
        position: fixed;
        top: 130px;
        left: 16px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 16px;
        border-radius: 12px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 13px;
        z-index: 100;
        backdrop-filter: blur(10px);
        display: none;
        min-width: 200px;
      }
      .settings-panel.visible {
        display: block;
      }
      .settings-panel h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        opacity: 0.9;
      }
      .settings-option {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.1);
      }
      .settings-option:last-child {
        border-bottom: none;
      }
      .settings-option input[type="radio"] {
        accent-color: #3b82f6;
      }
      .debug-panel {
        position: fixed;
        top: 120px;
        right: 16px;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 16px;
        border-radius: 12px;
        font-family: ui-monospace, monospace;
        font-size: 12px;
        z-index: 10000;
        min-width: 160px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: none;
      }
      .error-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        color: white;
        font-family: system-ui, -apple-system, sans-serif;
        padding: 20px;
        text-align: center;
      }
      .error-overlay.hidden {
        display: none;
      }
      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }
      .error-title {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 8px;
      }
      .error-message {
        font-size: 14px;
        opacity: 0.8;
        max-width: 300px;
        margin-bottom: 20px;
      }
      .error-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="loading" id="loading">
      <div style="font-size: 32px; margin-bottom: 20px;">üì±</div>
      <p style="font-size: 18px; font-weight: 600;">Memuat AR Experience</p>
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Memulai...</div>
        <div class="progress-detail" id="progressDetail"></div>
      </div>
    </div>

    <div class="error-overlay hidden" id="errorOverlay">
      <div class="error-icon">‚ö†Ô∏è</div>
      <div class="error-title" id="errorTitle">Terjadi Kesalahan</div>
      <div class="error-message" id="errorMessage">Tidak dapat memuat AR experience.</div>
      <button class="error-btn" onclick="location.reload()">Coba Lagi</button>
    </div>

    <div class="hint" id="hint">üì± Arahkan kamera ke salah satu marker</div>
    <div class="marker-count" id="marker-count"></div>
    
    <button class="settings-btn" id="settingsBtn" onclick="toggleSettings()">
      ‚öôÔ∏è Kualitas
    </button>
    
    <div class="settings-panel" id="settingsPanel">
      <h4>Pengaturan Kualitas</h4>
      <div class="settings-option">
        <input type="radio" name="quality" id="quality-auto" value="auto" checked>
        <label for="quality-auto">Auto (Rekomendasi)</label>
      </div>
      <div class="settings-option">
        <input type="radio" name="quality" id="quality-high" value="high">
        <label for="quality-high">Tinggi</label>
      </div>
      <div class="settings-option">
        <input type="radio" name="quality" id="quality-medium" value="medium">
        <label for="quality-medium">Sedang</label>
      </div>
      <div class="settings-option">
        <input type="radio" name="quality" id="quality-low" value="low">
        <label for="quality-low">Rendah (Hemat)</label>
      </div>
    </div>

    <div class="debug-panel" id="debugPanel"></div>

    <script>
      // ============= Configuration =============
      const CONFIG = {
        MAX_SIMULTANEOUS_TRACK: 2,
        CAMERA_RESOLUTIONS: {
          low: { width: 640, height: 480 },
          medium: { width: 960, height: 540 },
          high: { width: 1280, height: 720 },
        },
        FPS_TARGET: 30,
        CACHE_DB_NAME: 'ar-cache',
        CACHE_STORE_NAME: 'assets',
        CACHE_EXPIRY_DAYS: 7,
        RETRY_ATTEMPTS: 3,
        RETRY_DELAY: 1000,
        MARKER_HINT_TIMEOUT: 30000,
      };

      // ============= State =============
      let markers = [];
      let loadedMarkers = [];
      let activeMarkerCount = 0;
      let currentQuality = localStorage.getItem('ar-quality') || 'auto';
      let debugMode = new URLSearchParams(window.location.search).has('debug');
      let fpsCounter = { frames: 0, lastTime: performance.now(), fps: 0 };
      let loadStartTime = performance.now();
      let markerHintTimeout = null;
      let cacheDB = null;

      // ============= Cache System =============
      async function initCache() {
        return new Promise((resolve) => {
          try {
            const request = indexedDB.open(CONFIG.CACHE_DB_NAME, 1);
            request.onerror = () => resolve(null);
            request.onsuccess = () => {
              cacheDB = request.result;
              resolve(cacheDB);
            };
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(CONFIG.CACHE_STORE_NAME)) {
                db.createObjectStore(CONFIG.CACHE_STORE_NAME, { keyPath: 'url' });
              }
            };
          } catch {
            resolve(null);
          }
        });
      }

      async function getCached(url) {
        if (!cacheDB) return null;
        return new Promise((resolve) => {
          try {
            const tx = cacheDB.transaction(CONFIG.CACHE_STORE_NAME, 'readonly');
            const store = tx.objectStore(CONFIG.CACHE_STORE_NAME);
            const req = store.get(url);
            req.onsuccess = () => {
              const result = req.result;
              if (result && result.expiresAt > Date.now()) {
                console.log('[Cache] HIT:', url.slice(0, 40));
                resolve(result.blob);
              } else {
                resolve(null);
              }
            };
            req.onerror = () => resolve(null);
          } catch {
            resolve(null);
          }
        });
      }

      async function setCache(url, blob) {
        if (!cacheDB) return;
        try {
          const tx = cacheDB.transaction(CONFIG.CACHE_STORE_NAME, 'readwrite');
          const store = tx.objectStore(CONFIG.CACHE_STORE_NAME);
          store.put({
            url,
            blob,
            expiresAt: Date.now() + CONFIG.CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000,
          });
          console.log('[Cache] STORED:', url.slice(0, 40));
        } catch (e) {
          console.warn('[Cache] Store failed:', e);
        }
      }

      async function fetchWithCache(url, onProgress) {
        // Try cache first
        const cached = await getCached(url);
        if (cached) {
          onProgress?.(100);
          return URL.createObjectURL(cached);
        }

        // Fetch with progress and retry
        for (let attempt = 0; attempt < CONFIG.RETRY_ATTEMPTS; attempt++) {
          try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const contentLength = response.headers.get('content-length');
            const total = contentLength ? parseInt(contentLength, 10) : 0;

            if (!response.body) {
              const blob = await response.blob();
              await setCache(url, blob);
              onProgress?.(100);
              return URL.createObjectURL(blob);
            }

            const reader = response.body.getReader();
            const chunks = [];
            let received = 0;

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              chunks.push(value);
              received += value.length;
              if (total > 0) onProgress?.(Math.round((received / total) * 100));
            }

            const blob = new Blob(chunks);
            await setCache(url, blob);
            onProgress?.(100);
            return URL.createObjectURL(blob);
          } catch (e) {
            console.warn(`[Fetch] Attempt ${attempt + 1} failed:`, e);
            if (attempt < CONFIG.RETRY_ATTEMPTS - 1) {
              await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY));
            }
          }
        }

        // Fallback to direct URL
        console.warn('[Fetch] All retries failed, using direct URL');
        onProgress?.(100);
        return url;
      }

      // ============= Device Detection =============
      function detectDevice() {
        const ua = navigator.userAgent;
        const isMobile = /Android|iPhone|iPad|iPod/i.test(ua);
        const isTablet = /iPad|Android/i.test(ua) && Math.min(screen.width, screen.height) > 600;
        
        if (isTablet) return 'tablet';
        if (isMobile) return 'mobile';
        return 'desktop';
      }

      function getOptimalCameraResolution() {
        const quality = currentQuality === 'auto' ? getAutoQuality() : currentQuality;
        return CONFIG.CAMERA_RESOLUTIONS[quality] || CONFIG.CAMERA_RESOLUTIONS.medium;
      }

      function getAutoQuality() {
        const device = detectDevice();
        switch (device) {
          case 'mobile': return 'low';
          case 'tablet': return 'medium';
          default: return 'high';
        }
      }

      // ============= UI Updates =============
      function updateProgress(percent, text, detail = '') {
        document.getElementById('progressFill').style.width = `${percent}%`;
        document.getElementById('progressText').textContent = text;
        document.getElementById('progressDetail').textContent = detail;
      }

      function showError(title, message) {
        document.getElementById('errorTitle').textContent = title;
        document.getElementById('errorMessage').textContent = message;
        document.getElementById('errorOverlay').classList.remove('hidden');
        document.getElementById('loading').classList.add('hidden');
      }

      function toggleSettings() {
        const panel = document.getElementById('settingsPanel');
        panel.classList.toggle('visible');
      }

      function updateHint(text, isSuccess = false) {
        const hint = document.getElementById('hint');
        hint.textContent = text;
        hint.style.background = isSuccess ? 'rgba(34, 197, 94, 0.9)' : 'rgba(0, 0, 0, 0.7)';
      }

      // ============= Performance Monitor =============
      function updateDebugPanel() {
        if (!debugMode) return;
        
        const panel = document.getElementById('debugPanel');
        panel.style.display = 'block';
        
        const fpsColor = fpsCounter.fps >= 25 ? '#22c55e' : fpsCounter.fps >= 20 ? '#eab308' : '#ef4444';
        const resolution = getOptimalCameraResolution();
        
        panel.innerHTML = `
          <div style="margin-bottom: 8px; font-weight: bold; color: ${fpsColor};">
            FPS: ${fpsCounter.fps}
          </div>
          <div style="opacity: 0.8; line-height: 1.6;">
            Active: ${activeMarkerCount}<br>
            Camera: ${resolution.width}x${resolution.height}<br>
            Quality: ${currentQuality}<br>
            Load: ${Math.round(performance.now() - loadStartTime)}ms
          </div>
        `;
      }

      function measureFPS() {
        fpsCounter.frames++;
        const now = performance.now();
        if (now - fpsCounter.lastTime >= 1000) {
          fpsCounter.fps = Math.round((fpsCounter.frames * 1000) / (now - fpsCounter.lastTime));
          fpsCounter.frames = 0;
          fpsCounter.lastTime = now;
          updateDebugPanel();
        }
        requestAnimationFrame(measureFPS);
      }

      // ============= Quality Settings =============
      document.querySelectorAll('input[name="quality"]').forEach((radio) => {
        radio.addEventListener('change', (e) => {
          currentQuality = e.target.value;
          localStorage.setItem('ar-quality', currentQuality);
          // Would need scene reload to apply - for now just save preference
          toggleSettings();
        });
      });

      // Set initial quality radio
      const savedQuality = localStorage.getItem('ar-quality') || 'auto';
      const radioToCheck = document.getElementById(`quality-${savedQuality}`);
      if (radioToCheck) radioToCheck.checked = true;

      // ============= Media Preloader with Lazy Loading =============
      async function preloadMarkerData(marker, index, total) {
        updateProgress(
          Math.round(((index + 0.5) / total) * 80) + 10,
          `Memuat marker ${index + 1}/${total}...`,
          marker.name || `Marker ${index + 1}`
        );

        // Only load metadata for video, actual video loads on marker detection
        if (marker.type === 'video') {
          return new Promise((resolve) => {
            const video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.preload = 'metadata';
            
            const timeout = setTimeout(() => {
              resolve({ ...marker, width: 16, height: 9, loaded: false });
            }, 5000);

            video.onloadedmetadata = () => {
              clearTimeout(timeout);
              resolve({
                ...marker,
                width: video.videoWidth,
                height: video.videoHeight,
                loaded: false, // Will load fully on detection
              });
            };
            
            video.onerror = () => {
              clearTimeout(timeout);
              resolve({ ...marker, width: 16, height: 9, loaded: false });
            };
            
            video.src = marker.content;
          });
        } else {
          // Images - preload with cache
          return new Promise(async (resolve) => {
            try {
              const blobUrl = await fetchWithCache(marker.content, (p) => {
                updateProgress(
                  Math.round(((index + p / 100) / total) * 80) + 10,
                  `Memuat gambar ${index + 1}/${total}...`,
                  `${p}%`
                );
              });
              
              const img = new Image();
              img.crossOrigin = 'anonymous';
              
              const timeout = setTimeout(() => {
                resolve({ ...marker, width: 16, height: 9, blobUrl, loaded: true });
              }, 5000);

              img.onload = () => {
                clearTimeout(timeout);
                resolve({
                  ...marker,
                  width: img.naturalWidth,
                  height: img.naturalHeight,
                  blobUrl,
                  loaded: true,
                });
              };
              
              img.onerror = () => {
                clearTimeout(timeout);
                resolve({ ...marker, width: 16, height: 9, blobUrl: marker.content, loaded: true });
              };
              
              img.src = blobUrl;
            } catch (e) {
              resolve({ ...marker, width: 16, height: 9, loaded: false });
            }
          });
        }
      }

      // ============= Main AR Scene Creation =============
      async function createMultiTargetScene() {
        console.log('Loading', markers.length, 'markers');

        // Initialize cache
        updateProgress(5, 'Menyiapkan cache...');
        await initCache();

        // Load mind file with cache
        updateProgress(10, 'Memuat tracking data...');
        const mindUrl = await fetchWithCache(markers[0].mind, (p) => {
          updateProgress(5 + (p / 100) * 5, 'Memuat tracking data...', `${p}%`);
        });

        // Preload all markers (metadata only for videos)
        loadedMarkers = [];
        for (let i = 0; i < markers.length; i++) {
          const loaded = await preloadMarkerData(markers[i], i, markers.length);
          loadedMarkers.push(loaded);
        }

        updateProgress(90, 'Menyiapkan kamera...');

        // Get optimal camera settings
        const resolution = getOptimalCameraResolution();
        const maxTrack = Math.min(CONFIG.MAX_SIMULTANEOUS_TRACK, loadedMarkers.length);

        // Create A-Frame scene with optimized settings
        const scene = document.createElement('a-scene');
        scene.setAttribute(
          'mindar-image',
          `imageTargetSrc: ${mindUrl}; ` +
            `autoStart: true; ` +
            `uiLoading: no; ` +
            `uiScanning: no; ` +
            `uiError: no; ` +
            `maxTrack: ${maxTrack}; ` +
            `filterMinCF: 0.001; ` +
            `filterBeta: 1000; ` +
            `warmupTolerance: 2; ` +
            `missTolerance: 3;`
        );
        scene.setAttribute('color-space', 'sRGB');
        scene.setAttribute(
          'renderer',
          'antialias: false; alpha: true; precision: medium; logarithmicDepthBuffer: false'
        );
        scene.setAttribute('vr-mode-ui', 'enabled: false');
        scene.setAttribute('device-orientation-permission-ui', 'enabled: false');

        // Create assets container
        const assets = document.createElement('a-assets');
        assets.setAttribute('timeout', '30000');

        // Add assets - only images, videos load lazily
        loadedMarkers.forEach((marker, index) => {
          if (marker.type !== 'video') {
            const img = document.createElement('img');
            img.id = `ar-image-${index}`;
            img.src = marker.blobUrl || marker.content;
            img.setAttribute('crossorigin', 'anonymous');
            assets.appendChild(img);
          }
        });

        scene.appendChild(assets);

        // Camera entity
        const camera = document.createElement('a-camera');
        camera.setAttribute('position', '0 0 0');
        camera.setAttribute('look-controls', 'enabled: false');
        scene.appendChild(camera);

        // Create marker targets
        loadedMarkers.forEach((marker, index) => {
          const aspectRatio = marker.width / marker.height;
          const baseWidth = 1 * marker.scale;
          const baseHeight = (1 / aspectRatio) * marker.scale;

          const targetEntity = document.createElement('a-entity');
          targetEntity.setAttribute('mindar-image-target', `targetIndex: ${index}`);
          targetEntity.id = `target-${index}`;

          if (marker.type === 'video') {
            // Create video element (but don't add to assets yet)
            const videoEl = document.createElement('video');
            videoEl.id = `ar-video-${index}`;
            videoEl.setAttribute('preload', 'metadata');
            videoEl.setAttribute('loop', 'true');
            videoEl.setAttribute('playsinline', '');
            videoEl.setAttribute('webkit-playsinline', '');
            videoEl.setAttribute('crossorigin', 'anonymous');
            videoEl.muted = true;
            videoEl.style.display = 'none';
            document.body.appendChild(videoEl);

            const videoPlane = document.createElement('a-video');
            videoPlane.setAttribute('src', `#ar-video-${index}`);
            videoPlane.setAttribute('position', '0 0 0');
            videoPlane.setAttribute('width', baseWidth);
            videoPlane.setAttribute('height', baseHeight);
            videoPlane.setAttribute('rotation', '0 0 0');
            videoPlane.setAttribute('visible', 'false');
            targetEntity.appendChild(videoPlane);
          } else {
            const imagePlane = document.createElement('a-image');
            imagePlane.setAttribute('src', `#ar-image-${index}`);
            imagePlane.setAttribute('position', '0 0 0');
            imagePlane.setAttribute('width', baseWidth);
            imagePlane.setAttribute('height', baseHeight);
            imagePlane.setAttribute('rotation', '0 0 0');
            targetEntity.appendChild(imagePlane);
          }

          // Target found event - lazy load video
          targetEntity.addEventListener('targetFound', async () => {
            console.log('Found:', marker.name);
            activeMarkerCount++;
            updateHint(`‚úÖ ${marker.name} terdeteksi!`, true);
            clearTimeout(markerHintTimeout);

            if (marker.type === 'video') {
              const video = document.getElementById(`ar-video-${index}`);
              const videoPlane = targetEntity.querySelector('a-video');
              
              if (video && !marker.loaded) {
                // Lazy load video with cache
                updateHint(`‚è≥ Memuat video...`, false);
                const blobUrl = await fetchWithCache(marker.content);
                video.src = blobUrl;
                video.load();
                
                video.onloadeddata = () => {
                  marker.loaded = true;
                  videoPlane.setAttribute('visible', 'true');
                  video.muted = false;
                  video.play().catch(e => console.log('Play error:', e));
                  updateHint(`‚úÖ ${marker.name} terdeteksi!`, true);
                };
              } else if (video && marker.loaded) {
                videoPlane.setAttribute('visible', 'true');
                video.muted = false;
                video.play().catch(e => console.log('Play error:', e));
              }
            }
          });

          // Target lost event
          targetEntity.addEventListener('targetLost', () => {
            console.log('Lost:', marker.name);
            activeMarkerCount = Math.max(0, activeMarkerCount - 1);
            
            if (activeMarkerCount === 0) {
              updateHint('üì± Arahkan ke salah satu marker', false);
            }

            if (marker.type === 'video') {
              const video = document.getElementById(`ar-video-${index}`);
              if (video) video.pause();
            }
          });

          scene.appendChild(targetEntity);
        });

        document.body.appendChild(scene);

        // AR Ready event
        scene.addEventListener('arReady', () => {
          console.log('Multi-target AR ready');
          const loadTime = Math.round(performance.now() - loadStartTime);
          console.log(`Load time: ${loadTime}ms`);
          
          updateProgress(100, 'Siap!');
          setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
          }, 500);

          // Show hint if no marker detected after timeout
          markerHintTimeout = setTimeout(() => {
            if (activeMarkerCount === 0) {
              updateHint('üí° Pastikan marker terlihat jelas oleh kamera', false);
            }
          }, CONFIG.MARKER_HINT_TIMEOUT);

          // Start FPS monitoring
          if (debugMode) {
            measureFPS();
          }
        });

        // AR Error event
        scene.addEventListener('arError', (e) => {
          console.error('AR Error:', e);
          showError(
            'Kamera Tidak Tersedia',
            'Pastikan browser memiliki izin untuk mengakses kamera. Coba refresh halaman.'
          );
        });
      }

      // ============= Initialize =============
      const params = new URLSearchParams(window.location.search);
      const markersParam = params.get('markers');

      if (markersParam) {
        try {
          markers = JSON.parse(decodeURIComponent(markersParam));
        } catch (e) {
          console.error('Parse error:', e);
        }
      }

      if (markers.length === 0) {
        showError('Tidak Ada Marker', 'Konten AR tidak ditemukan atau telah dihapus.');
      } else {
        document.getElementById('marker-count').textContent = `${markers.length} marker tersedia`;
        createMultiTargetScene();
      }
    </script>
  </body>
</html>
